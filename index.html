<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Web-blox Pure Engine</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: monospace; color: #0f0; }
        #overlay { position: absolute; top: 10px; left: 10px; z-index: 10; background: rgba(0,0,0,0.7); padding: 15px; border: 1px solid #0f0; }
        input, button { background: #111; color: #0f0; border: 1px solid #0f0; padding: 5px; cursor: pointer; }
    </style>
</head>
<body>

    <div id="overlay">
        <div>
            <strong>HOST:</strong> <input type="file" id="upload" accept=".rbxl">
            <br><small id="my-id">Generating ID...</small>
        </div>
        <hr>
        <div>
            <strong>JOIN:</strong> <input type="text" id="peer-id" placeholder="Paste Host ID">
            <button id="connect-btn">Connect</button>
        </div>
        <div id="status">Status: Standby</div>
    </div>

    <script>
        // --- 1. CORE ENGINE ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        scene.add(new THREE.GridHelper(100, 100), new THREE.AmbientLight(0xffffff, 0.6));
        const sun = new THREE.DirectionalLight(0xffffff, 0.8);
        sun.position.set(50, 100, 50);
        scene.add(sun);
        camera.position.set(30, 30, 30);
        camera.lookAt(0,0,0);

        // --- 2. MULTIPLAYER (PeerJS) ---
        const peer = new Peer(); 
        let conn;

        peer.on('open', id => { document.getElementById('my-id').innerText = "Your ID: " + id; });

        // HOST SIDE: Receive connection
        peer.on('connection', (c) => {
            conn = c;
            setupConnection();
            document.getElementById('status').innerText = "Client Connected!";
        });

        // CLIENT SIDE: Initiate connection
        document.getElementById('connect-btn').onclick = () => {
            const id = document.getElementById('peer-id').value;
            conn = peer.connect(id);
            setupConnection();
        };

        function setupConnection() {
            conn.on('data', (data) => {
                if (data.type === 'SCENE_DATA') {
                    renderFromData(data.payload);
                    document.getElementById('status').innerText = "Scene Synced";
                }
            });
        }

        // --- 3. PARSING & SYNCING ---
        document.getElementById('upload').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            const text = await file.text();
            const rawData = parseRobloxXML(text);
            
            renderFromData(rawData);
            
            // Broadcast to connected peers
            if (conn) conn.send({ type: 'SCENE_DATA', payload: rawData });
        });

        function parseRobloxXML(xmlText) {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(xmlText, "text/xml");
            const instances = [];
            const items = xmlDoc.getElementsByTagName("Item");

            for (let item of items) {
                if (item.getAttribute("class") === "Part") {
                    const props = item.querySelector('Properties');
                    const size = props.getElementsByTagName("Vector3")[0];
                    const cf = props.getElementsByTagName("CoordinateFrame")[0];
                    
                    instances.push({
                        size: { 
                            x: parseFloat(size.querySelector("X").textContent), 
                            y: parseFloat(size.querySelector("Y").textContent), 
                            z: parseFloat(size.querySelector("Z").textContent) 
                        },
                        cframe: Array.from(cf.children).reduce((acc, tag) => {
                            acc[tag.tagName] = parseFloat(tag.textContent);
                            return acc;
                        }, {})
                    });
                }
            }
            return instances;
        }

        function renderFromData(data) {
            // Clear old parts
            scene.children = scene.children.filter(c => c.type !== "Mesh");

            data.forEach(p => {
                const geo = new THREE.BoxGeometry(p.size.x, p.size.y, p.size.z);
                const mat = new THREE.MeshStandardMaterial({ color: 0x5555ff });
                const mesh = new THREE.Mesh(geo, mat);

                const m = new THREE.Matrix4().set(
                    p.cframe.R00, p.cframe.R01, p.cframe.R02, p.cframe.X,
                    p.cframe.R10, p.cframe.R11, p.cframe.R12, p.cframe.Y,
                    p.cframe.R20, p.cframe.R21, p.cframe.R22, p.cframe.Z,
                    0, 0, 0, 1
                );
                mesh.applyMatrix4(m);
                scene.add(mesh);
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>
