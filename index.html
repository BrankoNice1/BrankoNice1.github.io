<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web-blox Engine</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; display: flex; height: 100vh; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #222; color: white; overflow: hidden; }
        #explorer { width: 250px; background: #333; border-right: 1px solid #444; overflow-y: auto; padding: 10px; font-size: 13px; }
        #viewport { flex-grow: 1; position: relative; }
        .instance-item { padding: 2px 5px; cursor: pointer; border-bottom: 1px solid #3d3d3d; }
        .instance-item:hover { background: #444; }
        #ui-overlay { position: absolute; top: 10px; left: 10px; pointer-events: none; }
        input[type="file"] { pointer-events: auto; }
        h3 { font-size: 14px; margin-top: 0; color: #aaa; text-transform: uppercase; }
    </style>
</head>
<body>

    <div id="explorer">
        <h3>Explorer</h3>
        <input type="file" id="upload" accept=".rbxl">
        <div id="tree-root"></div>
    </div>

    <div id="viewport">
        <div id="ui-overlay">
            <div>Status: <span id="status">Idle</span></div>
        </div>
    </div>

    <script>
        // --- 1. ENGINE INITIALIZATION ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xa0a0a0);
        const camera = new THREE.PerspectiveCamera(75, (window.innerWidth - 250) / window.innerHeight, 0.1, 5000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth - 250, window.innerHeight);
        document.getElementById('viewport').appendChild(renderer.domElement);

        // Lighting
        const light = new THREE.DirectionalLight(0xffffff, 1);
        light.position.set(100, 100, 100);
        scene.add(light, new THREE.AmbientLight(0x404040, 0.5));
        camera.position.set(20, 20, 20);
        camera.lookAt(0,0,0);

        // --- 2. DATA MODEL & PARSING ---
        const treeRootDisplay = document.getElementById('tree-root');

        document.getElementById('upload').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            
            document.getElementById('status').innerText = "Loading " + file.name;
            const text = await file.text();
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(text, "text/xml");
            
            // Clear existing scene
            while(scene.children.length > 2) scene.remove(scene.children[scene.children.length-1]);
            treeRootDisplay.innerHTML = "";

            // Start recursive parse from the root <roblox> tag
            const robloxRoot = xmlDoc.getElementsByTagName("roblox")[0];
            parseInstance(robloxRoot, treeRootDisplay, scene);
            document.getElementById('status').innerText = "Running";
        });

        function parseInstance(xmlNode, uiParent, spatialParent) {
            for (let child of xmlNode.children) {
                if (child.tagName === "Item") {
                    const className = child.getAttribute("class");
                    const name = getName(child) || className;

                    // Create Explorer UI element
                    const div = document.createElement('div');
                    div.className = 'instance-item';
                    div.innerText = `ðŸ“„ ${name} (${className})`;
                    uiParent.appendChild(div);

                    let currentSpatial = spatialParent;

                    // Handle Physical Parts
                    if (className === "Part" || className === "SpawnLocation") {
                        currentSpatial = createThreePart(child, spatialParent);
                    }

                    // Recursively dive into children of this item
                    parseInstance(child, div, currentSpatial);
                }
            }
        }

        function getName(xmlItem) {
            const props = xmlItem.querySelector('Properties');
            if (!props) return null;
            const nameNode = Array.from(props.children).find(n => n.getAttribute('name') === 'Name');
            return nameNode ? nameNode.textContent : null;
        }

        function createThreePart(xmlItem, spatialParent) {
            const props = xmlItem.querySelector('Properties');
            
            // Extract Size
            const sizeNode = Array.from(props.getElementsByTagName("Vector3")).find(n => n.getAttribute("name") === "Size");
            const sw = sizeNode ? parseFloat(sizeNode.querySelector("X").textContent) : 4;
            const sh = sizeNode ? parseFloat(sizeNode.querySelector("Y").textContent) : 1;
            const sd = sizeNode ? parseFloat(sizeNode.querySelector("Z").textContent) : 2;

            // Extract CFrame
            const cfNode = Array.from(props.getElementsByTagName("CoordinateFrame")).find(n => n.getAttribute("name") === "CFrame");
            const m = { X:0, Y:0, Z:0, R00:1, R01:0, R02:0, R10:0, R11:1, R12:0, R20:0, R21:0, R22:1 };
            if (cfNode) {
                for (let tag of cfNode.children) m[tag.tagName] = parseFloat(tag.textContent);
            }

            const geometry = new THREE.BoxGeometry(sw, sh, sd);
            const material = new THREE.MeshStandardMaterial({ color: 0xcccccc });
            const mesh = new THREE.Mesh(geometry, material);

            const matrix = new THREE.Matrix4();
            matrix.set(
                m.R00, m.R01, m.R02, m.X,
                m.R10, m.R11, m.R12, m.Y,
                m.R20, m.R21, m.R22, m.Z,
                0,     0,     0,     1
            );
            mesh.applyMatrix4(matrix);
            
            scene.add(mesh);
            return mesh;
        }

        // --- 3. ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        animate();

        // Handle Resize
        window.addEventListener('resize', () => {
            camera.aspect = (window.innerWidth - 250) / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth - 250, window.innerHeight);
        });
    </script>
</body>
</html>
